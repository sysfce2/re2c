%code requires {

namespace re2c {
class SyntaxConfig;
} // namespace re2c

}

%{
#include <stdint.h>

#include "src/codegen/syntax.h"
#include "src/codegen/syntax_parser.h"
#include "src/msg/msg.h"

using namespace re2c;

extern "C" {
    static void yyerror(SyntaxConfig& cfg, const char* s);
    static int yylex(YYSTYPE* yylval, SyntaxConfig& cfg);
}

%}

%start spec

%define api.pure full
%lex-param {re2c::SyntaxConfig& cfg}
%parse-param {re2c::SyntaxConfig& cfg}

%union {
    const char* str;
    int32_t num;
};

%token TOKEN_NAME
%token TOKEN_NUMBER
%token TOKEN_STRING
%token TOKEN_CONFIG
%token TOKEN_ERROR

%type <str> TOKEN_NAME TOKEN_STRING TOKEN_CONFIG

%%

spec
    : %empty
    | spec config;

config: TOKEN_CONFIG expr ';';

expr
    : %empty
    | expr expr1;

expr1
    : opt
    | list
    | atom
    | TOKEN_NUMBER;

opt
    : '(' TOKEN_NAME '?' expr ')'
    | '(' TOKEN_NAME '?' expr ':' expr ')';

list
    : '[' TOKEN_NAME ':' expr ']'
    | '[' TOKEN_NAME '{' TOKEN_NUMBER ':' TOKEN_NUMBER '}' ':' expr ']';

atom
    : TOKEN_STRING
    | TOKEN_NAME
    | TOKEN_NAME '{' TOKEN_NUMBER '}'
    | '(' expr ')';

%%

extern "C" {
    static void yyerror(re2c::SyntaxConfig&, const char* s) {
        error("%s", s);
    }

    static int yylex(YYSTYPE* yylval, re2c::SyntaxConfig& cfg) {
        return cfg.lex_token(yylval);
    }
}

namespace re2c {

Ret SyntaxConfig::parse() {
    return yyparse(*this) == 0 ? Ret::OK : Ret::FAIL;
}

} // namespace re2c
