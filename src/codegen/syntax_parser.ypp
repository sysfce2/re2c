%{
#include <stdint.h>

#include "src/codegen/syntax.h"
#include "src/codegen/syntax_parser.h"
#include "src/msg/msg.h"

using namespace re2c;

extern "C" {
    static void yyerror(const uint8_t** cursor, const char* s);
    static int yylex(YYSTYPE* yylval, const uint8_t** cursor);
}

%}

%start spec

%define api.pure full
%lex-param {const uint8_t** cursor}
%parse-param {const uint8_t** cursor}

%union {
    const char* str;
    int32_t num;
};

%token TOKEN_NAME
%token TOKEN_NUMBER
%token TOKEN_STRING
%token TOKEN_CONFIG
%token TOKEN_ERROR

%type <str> TOKEN_NAME TOKEN_STRING TOKEN_CONFIG

%%

spec
    : %empty
    | spec config;

config: TOKEN_CONFIG expr ';';

expr
    : %empty
    | expr expr1;

expr1
    : opt
    | list
    | atom
    | TOKEN_NUMBER;

opt
    : '(' TOKEN_NAME '?' expr ')'
    | '(' TOKEN_NAME '?' expr ':' expr ')';

list
    : '[' TOKEN_NAME ':' expr ']'
    | '[' TOKEN_NAME '{' TOKEN_NUMBER ':' TOKEN_NUMBER '}' ':' expr ']';

atom
    : TOKEN_STRING
    | TOKEN_NAME
    | TOKEN_NAME '{' TOKEN_NUMBER '}'
    | '(' expr ')';

%%

extern "C" {
    static void yyerror(const uint8_t**, const char* s) {
        error("%s", s);
    }

    static int yylex(YYSTYPE* yylval, const uint8_t** cursor) {
        return lex_syntax_file(yylval, cursor);
    }
}

namespace re2c {

Ret parse_syntax_file(const uint8_t** cursor) {
    return yyparse(cursor) == 0 ? Ret::OK : Ret::FAIL;
}

} // namespace re2c
