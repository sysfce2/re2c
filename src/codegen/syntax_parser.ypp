%code requires {

#include "src/util/containers.h"

namespace re2c {
struct StxConf;
struct StxBool;
struct StxExpr;
using StxExprList = list_t<StxExpr>;
class Stx;
class StxFile;
} // namespace re2c

}

%{
#include <stdint.h>

#include "src/codegen/syntax.h"
#include "src/codegen/syntax_parser.h"
#include "src/msg/msg.h"

using namespace re2c;

extern "C" {
    static void yyerror(StxFile& sf, re2c::Stx&, const char* s);
    static int yylex(YYSTYPE* yylval, StxFile& sf);
}

%}

%start confs

%define api.pure full
%lex-param {re2c::StxFile& sf}
%parse-param {re2c::StxFile& sf}
%parse-param {re2c::Stx& stx}

%union {
    const char* str;
    int32_t num;
    re2c::StxConf* conf;
    re2c::StxBool* bln;
    re2c::StxExpr* expr;
    re2c::StxExprList* exprs;
};

%token TOKEN_NAME
%token TOKEN_NUMBER
%token TOKEN_STRING
%token TOKEN_CONFIG

%type <str>   TOKEN_NAME TOKEN_STRING TOKEN_CONFIG
%type <num>   TOKEN_NUMBER
%type <conf>  conf
%type <expr>  expr cond_expr list_expr
%type <exprs> exprs
%type <bln>   bool

%%

confs
: %empty
| conf confs { stx.confs[$1->name] = $1; };

conf
: TOKEN_CONFIG exprs ';' { $$ = stx.make_conf_expr($1, $2); }
| TOKEN_CONFIG bool  ';' { $$ = stx.make_conf_bool($1, $2); };

exprs
: %empty     { $$ = stx.new_expr_list(); }
| expr exprs { prepend($2, $1); $$ = $2; };

expr
: TOKEN_STRING                    { $$ = stx.make_str($1); }
| TOKEN_NAME                      { $$ = stx.make_var($1, -1); }
| TOKEN_NAME '{' TOKEN_NUMBER '}' { $$ = stx.make_var($1, $3); }
| cond_expr
| list_expr;

cond_expr
: '(' TOKEN_NAME '?' exprs ')'           { $$ = stx.make_cond($2, $4, nullptr); }
| '(' TOKEN_NAME '?' exprs ':' exprs ')' { $$ = stx.make_cond($2, $4, $6); };

list_expr
: '[' TOKEN_NAME ':' exprs ']' {
    $$ = stx.make_list($2, 0, -1, $4);
}
| '[' TOKEN_NAME '{' TOKEN_NUMBER ':' TOKEN_NUMBER '}' ':' exprs ']' {
    $$ = stx.make_list($2, $4, $6, $9);
};

bool
: TOKEN_NUMBER                         { $$ = stx.make_bool_num($1); }
| '(' TOKEN_NAME '?' bool ':' bool ')' { $$ = stx.make_bool_cond($2, $4, $6); };

%%

extern "C" {
    static void yyerror(re2c::StxFile& sf, re2c::Stx&, const char* s) {
        sf.msg.error(sf.tok_loc(), "%s", s);
    }

    static int yylex(YYSTYPE* yylval, re2c::StxFile& sf) {
        return sf.lex_token(yylval);
    }
}

namespace re2c {

Ret StxFile::parse(Stx& stx) {
    return yyparse(*this, stx) == 0 ? Ret::OK : Ret::FAIL;
}

} // namespace re2c
